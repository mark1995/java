### 初级面试题纲
1. Java中重写和重载的区别 
	重写：子类重写父类的方法
	重载：同一类中的方法名相同，函数签名不同（参数个数，参数类型， 顺序不同）区分
	两个本质上没有任何关系
2. == 和 equals 
	判断是否相等
	== 如果是基本的数据类型，比较的就是数值是否相等，比较的如果是对象，就是引用的地址是否相同
	equals Object.java中实现的就是引用对象的地址是否相同，但是不同的类，可以重写equals方法，自定义对象的相等判断，这里就可以是内容相同或者是地址相同，都可以了。
	比如String类就重写了equals方法，他就是比较字符串里的内容是不是相同，注意一般的如果你重写的了equals方法呢，一般也要重写hashcode方法（除非这些对象不会放在散列集合中使用），
	因为hashcode定义了语义，如果两个对象的equals相等，那么他们的hashcode值应该是一样的，但是反过来是不成立的，
3. Java的异常处理机制是什么
	五个关键字
	throw :在方法里 throw new Exception();
	try catch finally 方法里面使用，finally都会执行（除了显示调用System.exit(0)），一个try可以对应多个catch,每个catch，可以具体到某种具体的异常，从上到下由具体到抽象排列。
	throws :声明在 方法声明出，提示调用者处理异常


	java的异常机制 改变 程序的控制流，这个说法对也不对，不对的地方在于本质上是没有改变的，你可以对每个有可能出现异常的地方，都可以catch住，并做出相应合理的处理，但是从编码便捷性和编码的可读性上，更多的是在方法里面的外层来统一处理各种异常，这样在这些代码块中 只要出现一个异常，不管这个异常是否影响你的主流程逻辑都会导致这个代码的控制流发现变化，直接去到了相应的catch地方。

	java的异常体系：Error类，发生了一些程序无法处理的错误，一般是系统级别的，程序要退出
	Exception类：本质上都是运行时异常，一个是提前显示声明了这些异常，你的上层业务处理的时候，在编码阶段就要想好怎么处理这些异常情况。
		-	RuntimeException：运行时异常，例如空指针异常，数组越界异常等，
		-	Checked异常，文件不存在这些异常，这些都是提前可以预料到的异常，一般也是底层程序throw出来了，让上层调用者显示处理这一类的异常，本质上呢，也应该是运行时异常，不过底层明确指明了这些方法根据你的参数会出现这这类的异常，出现了你的上层逻辑应该要怎么处理。

4. 自定义异常如何在生产中应用
	-	自定义异常，可以明确某一类业务逻辑的异常
	-	分层中，统一在外层处理异常，统一进行捕获
5. Java代理模式的实现方式 （Spring AOP源码）
	代理模式，代理对象 目标对象，代理对象里面包含了目标对象（组合方式），同时加强了目标对象的功能，，实现同一个接口
	-	静态代理：为啥称之为静态代理，是代理类在编译的时候就生成了一个class文件，jvm直接加载之后就可以使用了。
	-	动态代理：区别在代理类在编译阶段并没有生产class文件，而是在运行阶段，动态生成字节码，动态加载到jvm运行。
		+	JDK动态代理（java反射实现）
			*	统一是proxy的子类，并且实现了代理相关的接口，缺点使用反射效率点，并且指定接口，侵入式
		+	cglib动态代理 （asm实现）
			*	动态生成一个目标类的子类，重写子类的方法，增强方法，没有侵入式，不需要知道接口
6. hashcode 和 equals 如何使用
	散列集合中的contains判断和散列碰撞会使用到equals方法
7. String、StringBuffer、StringBuilder区别和使用场景
	- String 不可变的类
	- StringBuilder 线程不安全 (JDK 1.5)
	- StringBuffer 线程安全 （JDK1.0）
8. 声明一个类不能被继承，，什么场景下会使用
	-	不能重写，final修饰类，
	-	使用场景
		+	工具类可以定义为final，public final class Math{}
9. 	什么是拆箱，装箱
	两者说的是基本数据类型和相应的引用类型之间的隐式转换
	-	拆箱：int y = new Integer(2);
	-	装箱：Integer x = 2;
10. 八种基本数据类型 对应 封装类，对应的缓存池
	-	byte/1 						Byte     			  -128到127
	-	char/2 (char是两个字节)		Character 			  
	-	short/2 					Short 				  -128到127
	-	int/4 						Integer 			  -128到127 	
	-	float/4（单进度浮点数）		Float
	-	double/8 					Double
	-	long/8 						Long 				
	-	boolean/1 					Boolean                true/false
11. Integer类的缓存池，-128-127
12. String.intern()
	String s1 = new String("ss");
	String s2 = new String("ss");
	s1 == s2 // false
	String s3 = s1.intern();
	s3 == s1; // true

	String final类，并且底层的char[]数组也是final修辞
	String s1 = "ss";   // 直接赋值常量字符串，是引用常量池的同一个字符串
	String s2 = "ss";
	s1 == s2 // true 
13. Java的参数传递都是按值传递，如果是对象，传递的是，参数为对象的引用地址，如果在调用方法中对这个参数指向的对象做修改是可以修改对象里面的内容的
	但是如果在调用方法中，参数被指向新的对象地址，在此修改就不能对之前引用的对象起作用了
14. 抽象类和接口的区别
	-	java8之前，接口是不能有任何实现，在java8开始，接口可以有默认的实现
	-	接口的所有成员都是public （方法，属性），而且字段 默认是 static final, 静态且不可变的
	-	A extends B ，说明A is a B 	（继承关系）
	-	A implements B 说明A like a B (契约关系)
	-	java还是单继承方式，并且重写抽象类的所用抽象方法
15. 抽象类和普通类的区别
	-	抽象类不能实例化对象
16. 什么时候使用抽象类
	-	几个类都有大量的共享代码，
17. Java 四种引用：强弱软虚
	-	强引用  强引用是平时使用最多的一种引用，就是OOM也不能被回收
	-	软引用 	内存不足会回收该部分的 SoftReference
	-	弱引用	WeakReference ,只要垃圾回收器发现了它，就会回收
	-	虚引用	
18. Java创建对象的方式
	-	new
	-	根据反射
	-	clone （拷贝）
	-	序列化
19. 不同对象的hashcode有没有可能相同
	-	会
	-	就会出现hash碰撞
		+	拉链法
		+	开放地址法
		+	再hash
20. 深拷贝、浅拷贝的区别 （实现Cloneable接口， clone方法，重写clone方法）
	-	拷贝的语义：将一个对象的属性 拷贝 到另外一个相同类型的对象中去，新的上下文环境中复用对象的部分数据 或者 全部数据
		+	深拷贝   引用类型 指向 新的地址空间，
		+	浅拷贝   拷贝出来的对象，里面的引用类型属性还是和原对象的引用类型指向同一地址空间，一改都改
		+	延迟拷贝  两者结合
21. Class.forName() 有啥用
	获取类的Class对象，同时也是加载了指定的类，
	获取Class对象的四种方式
	-	Class.forName(类的路径)
	-	类名.class
	-	对象名.getClass()
	-	
22. 反射中的 领域对象
	-	Class
	-	Field  		 属性
	-	Constructor  构造器
	-	Method		 方法
23. Spring中如何完美的处理好异常，统一处理





























